#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <cuda_runtime.h>
#include "d_colorToGreyscale.h"
#include "CHECK.h"

#define CHANNELS 3
__global__ void d_colorToGreyscaleKernel(unsigned char *, unsigned char *,
                                         int, int);
/*
   d_colorToGreyscale
   Performs the greyscale of an image on the GPU.
   Pout array is filled with the greyscale of each pixel.
   Pin array contains the color pixels.
   width and height are the dimensions of the image.
   blkWidth and blkHeight specify the block dimensions to use.
   Each thread generated by the kernel launch will handle two
   consecutive pixels in Pin.
*/
float d_colorToGreyscale(unsigned char * Pout, unsigned char * Pin,
                        int width, int height, int blkWidth, int blkHeight)
{
    cudaEvent_t start_cpu, stop_cpu;
    float cpuMsecTime = -1;
    unsigned char * d_Pout;
    unsigned char * d_Pin;
    int size = width * height * sizeof(unsigned char);

    //Use cuda functions to do the timing 
    //create event objects
    CHECK(cudaEventCreate(&start_cpu));
    CHECK(cudaEventCreate(&stop_cpu));
    //record the starting time
    CHECK(cudaEventRecord(start_cpu));

    //your code will go here
    //Your work goes here and in the kernel below
    CHECK(cudaMalloc((void **) &d_Pout, size));
    CHECK(cudaMalloc((void **) &d_Pin, size*CHANNELS));
   
    int bWidth = blkWidth;
    int bHeight = blkHeight;
    if (bWidth == 0) bWidth = 16;
    if (bHeight == 0) bHeight = 16;
    dim3 dimGrid(ceil(width/16.0),ceil(height/16.0), 1);
    dim3 dimBlock(bWidth,bHeight,1);

    CHECK(cudaMemcpy(d_Pin, Pin, (size * CHANNELS), cudaMemcpyHostToDevice));

    d_colorToGreyscaleKernel<<<dimGrid,dimBlock>>>(d_Pin, d_Pout, width, height);

    CHECK(cudaDeviceSynchronize());

    CHECK(cudaMemcpy(Pout, d_Pout, size, cudaMemcpyDeviceToHost));

    cudaFree(d_Pin);
    cudaFree(d_Pout);
 
    //record the ending time and wait for event to complete
    CHECK(cudaEventRecord(stop_cpu));
    CHECK(cudaEventSynchronize(stop_cpu));
    //calculate the elapsed time between the two events 
    CHECK(cudaEventElapsedTime(&cpuMsecTime, start_cpu, stop_cpu));
    return cpuMsecTime;
}

/*
   d_colorToGreyscaleKernel
   Kernel code executed by each thread on its own data when the kernel is
   launched.
   Pout array is filled with the greyscale of each pixel (one element per thread).
   Pin array contains the color pixels.
   width and height are the dimensions of the image.
   Each thread will handle two consecutive pixels in Pin.
*/
__global__
void d_colorToGreyscaleKernel(unsigned char * Pin, unsigned char * Pout,
                              int width, int height)
{
    //your kernel will go here

	//Single thread calculates two consecutive output elements
	int Col  = (threadIdx.x + blockIdx.x * blockDim.x) * 2;
        int Row  =  threadIdx.y + blockIdx.y * blockDim.y;

       	if (Col < width && Row < height) {
	      for (int i = 0; i < 2; i++) {
               	int greyOffset = (Row * width + Col) + i; //add i to access next three Pin pixels
               	int rgbOffset = greyOffset * CHANNELS;
               	unsigned char r = Pin[rgbOffset];
               	unsigned char g = Pin[rgbOffset + 1];
                unsigned char b = Pin[rgbOffset + 2];
       	        Pout[greyOffset] = 0.21f*r + 0.71f*g + 0.07f*b;
	      }
       	}
}
